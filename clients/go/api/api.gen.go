// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	SignatureAuthScopes = "signatureAuth.Scopes"
)

// EmailContact defines model for EmailContact.
type EmailContact struct {
	Address openapi_types.Email `json:"address"`
	Name    *string             `json:"name,omitempty"`
}

// EmailRequest defines model for EmailRequest.
type EmailRequest struct {
	Content *EmailRequest_Content `json:"content,omitempty"`
	From    EmailContact          `json:"from"`
	Subject string                `json:"subject"`

	// To A single recipient or an array of recipients.
	To EmailRequest_To `json:"to"`
}

// EmailRequestContent0 defines model for .
type EmailRequestContent0 struct {
	Body   string `json:"body"`
	IsHtml *bool  `json:"isHtml,omitempty"`
}

// EmailRequestContent1 defines model for .
type EmailRequestContent1 struct {
	Template struct {
		Data map[string]interface{} `json:"data"`
		Name string                 `json:"name"`
	} `json:"template"`
}

// EmailRequest_Content defines model for EmailRequest.Content.
type EmailRequest_Content struct {
	union json.RawMessage
}

// EmailRequestTo0 defines model for .
type EmailRequestTo0 = openapi_types.Email

// EmailRequestTo2 defines model for .
type EmailRequestTo2 = []EmailRequest_To_2_Item

// EmailRequestTo20 defines model for .
type EmailRequestTo20 = openapi_types.Email

// EmailRequest_To_2_Item defines model for EmailRequest.To.2.Item.
type EmailRequest_To_2_Item struct {
	union json.RawMessage
}

// EmailRequest_To A single recipient or an array of recipients.
type EmailRequest_To struct {
	union json.RawMessage
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Code    string    `json:"code"`
		Details *[]string `json:"details,omitempty"`
		Message string    `json:"message"`
	} `json:"error"`
	Success bool `json:"success"`
}

// SmsRecipient defines model for SmsRecipient.
type SmsRecipient struct {
	union json.RawMessage
}

// SmsRecipient0 Phone number in E.164 format.
type SmsRecipient0 = string

// SmsRecipient1 defines model for .
type SmsRecipient1 struct {
	// Country ISO 3166-1 alpha-2 country code.
	Country string `json:"country"`
	Phone   string `json:"phone"`
}

// SmsRequest defines model for SmsRequest.
type SmsRequest struct {
	Content    *SmsRequest_Content `json:"content,omitempty"`
	SenderName string              `json:"senderName"`

	// To A single recipient or an array of recipients.
	To SmsRequest_To `json:"to"`
}

// SmsRequestContent0 defines model for .
type SmsRequestContent0 struct {
	Body string `json:"body"`
}

// SmsRequestContent1 defines model for .
type SmsRequestContent1 struct {
	Template struct {
		Data map[string]interface{} `json:"data"`
		Name string                 `json:"name"`
	} `json:"template"`
}

// SmsRequest_Content defines model for SmsRequest.Content.
type SmsRequest_Content struct {
	union json.RawMessage
}

// SmsRequestTo1 defines model for .
type SmsRequestTo1 = []SmsRecipient

// SmsRequest_To A single recipient or an array of recipients.
type SmsRequest_To struct {
	union json.RawMessage
}

// SmsSuccessResponse defines model for SmsSuccessResponse.
type SmsSuccessResponse struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	Message string                  `json:"message"`
	Meta    *struct {
		Cost     *float32 `json:"cost,omitempty"`
		Currency *string  `json:"currency,omitempty"`
	} `json:"meta,omitempty"`
	Success bool `json:"success"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	Message string                  `json:"message"`
	Success bool                    `json:"success"`
}

// ClientIdHeader defines model for ClientIdHeader.
type ClientIdHeader = string

// TimestampHeader defines model for TimestampHeader.
type TimestampHeader = time.Time

// PostV3EmailParams defines parameters for PostV3Email.
type PostV3EmailParams struct {
	// XClientId The unique ID assigned to your service.
	XClientId ClientIdHeader `json:"X-Client-Id"`

	// XTimestamp ISO 8601 timestamp. Requests older than 5 minutes will be rejected.
	XTimestamp TimestampHeader `json:"X-Timestamp"`
}

// PostV3SmsParams defines parameters for PostV3Sms.
type PostV3SmsParams struct {
	// XClientId The unique ID assigned to your service.
	XClientId ClientIdHeader `json:"X-Client-Id"`

	// XTimestamp ISO 8601 timestamp. Requests older than 5 minutes will be rejected.
	XTimestamp TimestampHeader `json:"X-Timestamp"`
}

// PostV3EmailJSONRequestBody defines body for PostV3Email for application/json ContentType.
type PostV3EmailJSONRequestBody = EmailRequest

// PostV3SmsJSONRequestBody defines body for PostV3Sms for application/json ContentType.
type PostV3SmsJSONRequestBody = SmsRequest

// AsEmailRequestContent0 returns the union data inside the EmailRequest_Content as a EmailRequestContent0
func (t EmailRequest_Content) AsEmailRequestContent0() (EmailRequestContent0, error) {
	var body EmailRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestContent0 overwrites any union data inside the EmailRequest_Content as the provided EmailRequestContent0
func (t *EmailRequest_Content) FromEmailRequestContent0(v EmailRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestContent0 performs a merge with any union data inside the EmailRequest_Content, using the provided EmailRequestContent0
func (t *EmailRequest_Content) MergeEmailRequestContent0(v EmailRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailRequestContent1 returns the union data inside the EmailRequest_Content as a EmailRequestContent1
func (t EmailRequest_Content) AsEmailRequestContent1() (EmailRequestContent1, error) {
	var body EmailRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestContent1 overwrites any union data inside the EmailRequest_Content as the provided EmailRequestContent1
func (t *EmailRequest_Content) FromEmailRequestContent1(v EmailRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestContent1 performs a merge with any union data inside the EmailRequest_Content, using the provided EmailRequestContent1
func (t *EmailRequest_Content) MergeEmailRequestContent1(v EmailRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailRequestTo20 returns the union data inside the EmailRequest_To_2_Item as a EmailRequestTo20
func (t EmailRequest_To_2_Item) AsEmailRequestTo20() (EmailRequestTo20, error) {
	var body EmailRequestTo20
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo20 overwrites any union data inside the EmailRequest_To_2_Item as the provided EmailRequestTo20
func (t *EmailRequest_To_2_Item) FromEmailRequestTo20(v EmailRequestTo20) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo20 performs a merge with any union data inside the EmailRequest_To_2_Item, using the provided EmailRequestTo20
func (t *EmailRequest_To_2_Item) MergeEmailRequestTo20(v EmailRequestTo20) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailContact returns the union data inside the EmailRequest_To_2_Item as a EmailContact
func (t EmailRequest_To_2_Item) AsEmailContact() (EmailContact, error) {
	var body EmailContact
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailContact overwrites any union data inside the EmailRequest_To_2_Item as the provided EmailContact
func (t *EmailRequest_To_2_Item) FromEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailContact performs a merge with any union data inside the EmailRequest_To_2_Item, using the provided EmailContact
func (t *EmailRequest_To_2_Item) MergeEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_To_2_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_To_2_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailRequestTo0 returns the union data inside the EmailRequest_To as a EmailRequestTo0
func (t EmailRequest_To) AsEmailRequestTo0() (EmailRequestTo0, error) {
	var body EmailRequestTo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo0 overwrites any union data inside the EmailRequest_To as the provided EmailRequestTo0
func (t *EmailRequest_To) FromEmailRequestTo0(v EmailRequestTo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo0 performs a merge with any union data inside the EmailRequest_To, using the provided EmailRequestTo0
func (t *EmailRequest_To) MergeEmailRequestTo0(v EmailRequestTo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailContact returns the union data inside the EmailRequest_To as a EmailContact
func (t EmailRequest_To) AsEmailContact() (EmailContact, error) {
	var body EmailContact
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailContact overwrites any union data inside the EmailRequest_To as the provided EmailContact
func (t *EmailRequest_To) FromEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailContact performs a merge with any union data inside the EmailRequest_To, using the provided EmailContact
func (t *EmailRequest_To) MergeEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailRequestTo2 returns the union data inside the EmailRequest_To as a EmailRequestTo2
func (t EmailRequest_To) AsEmailRequestTo2() (EmailRequestTo2, error) {
	var body EmailRequestTo2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo2 overwrites any union data inside the EmailRequest_To as the provided EmailRequestTo2
func (t *EmailRequest_To) FromEmailRequestTo2(v EmailRequestTo2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo2 performs a merge with any union data inside the EmailRequest_To, using the provided EmailRequestTo2
func (t *EmailRequest_To) MergeEmailRequestTo2(v EmailRequestTo2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_To) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_To) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRecipient0 returns the union data inside the SmsRecipient as a SmsRecipient0
func (t SmsRecipient) AsSmsRecipient0() (SmsRecipient0, error) {
	var body SmsRecipient0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient0 overwrites any union data inside the SmsRecipient as the provided SmsRecipient0
func (t *SmsRecipient) FromSmsRecipient0(v SmsRecipient0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient0 performs a merge with any union data inside the SmsRecipient, using the provided SmsRecipient0
func (t *SmsRecipient) MergeSmsRecipient0(v SmsRecipient0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRecipient1 returns the union data inside the SmsRecipient as a SmsRecipient1
func (t SmsRecipient) AsSmsRecipient1() (SmsRecipient1, error) {
	var body SmsRecipient1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient1 overwrites any union data inside the SmsRecipient as the provided SmsRecipient1
func (t *SmsRecipient) FromSmsRecipient1(v SmsRecipient1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient1 performs a merge with any union data inside the SmsRecipient, using the provided SmsRecipient1
func (t *SmsRecipient) MergeSmsRecipient1(v SmsRecipient1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRecipient) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRecipient) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRequestContent0 returns the union data inside the SmsRequest_Content as a SmsRequestContent0
func (t SmsRequest_Content) AsSmsRequestContent0() (SmsRequestContent0, error) {
	var body SmsRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestContent0 overwrites any union data inside the SmsRequest_Content as the provided SmsRequestContent0
func (t *SmsRequest_Content) FromSmsRequestContent0(v SmsRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestContent0 performs a merge with any union data inside the SmsRequest_Content, using the provided SmsRequestContent0
func (t *SmsRequest_Content) MergeSmsRequestContent0(v SmsRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRequestContent1 returns the union data inside the SmsRequest_Content as a SmsRequestContent1
func (t SmsRequest_Content) AsSmsRequestContent1() (SmsRequestContent1, error) {
	var body SmsRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestContent1 overwrites any union data inside the SmsRequest_Content as the provided SmsRequestContent1
func (t *SmsRequest_Content) FromSmsRequestContent1(v SmsRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestContent1 performs a merge with any union data inside the SmsRequest_Content, using the provided SmsRequestContent1
func (t *SmsRequest_Content) MergeSmsRequestContent1(v SmsRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRecipient returns the union data inside the SmsRequest_To as a SmsRecipient
func (t SmsRequest_To) AsSmsRecipient() (SmsRecipient, error) {
	var body SmsRecipient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient overwrites any union data inside the SmsRequest_To as the provided SmsRecipient
func (t *SmsRequest_To) FromSmsRecipient(v SmsRecipient) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient performs a merge with any union data inside the SmsRequest_To, using the provided SmsRecipient
func (t *SmsRequest_To) MergeSmsRecipient(v SmsRecipient) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRequestTo1 returns the union data inside the SmsRequest_To as a SmsRequestTo1
func (t SmsRequest_To) AsSmsRequestTo1() (SmsRequestTo1, error) {
	var body SmsRequestTo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestTo1 overwrites any union data inside the SmsRequest_To as the provided SmsRequestTo1
func (t *SmsRequest_To) FromSmsRequestTo1(v SmsRequestTo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestTo1 performs a merge with any union data inside the SmsRequest_To, using the provided SmsRequestTo1
func (t *SmsRequest_To) MergeSmsRequestTo1(v SmsRequestTo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRequest_To) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRequest_To) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3EmailWithBody request with any body
	PostV3EmailWithBody(ctx context.Context, params *PostV3EmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV3Email(ctx context.Context, params *PostV3EmailParams, body PostV3EmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostV3SmsWithBody request with any body
	PostV3SmsWithBody(ctx context.Context, params *PostV3SmsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostV3Sms(ctx context.Context, params *PostV3SmsParams, body PostV3SmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3EmailWithBody(ctx context.Context, params *PostV3EmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3EmailRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3Email(ctx context.Context, params *PostV3EmailParams, body PostV3EmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3EmailRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3SmsWithBody(ctx context.Context, params *PostV3SmsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3SmsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostV3Sms(ctx context.Context, params *PostV3SmsParams, body PostV3SmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostV3SmsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostV3EmailRequest calls the generic PostV3Email builder with application/json body
func NewPostV3EmailRequest(server string, params *PostV3EmailParams, body PostV3EmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV3EmailRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV3EmailRequestWithBody generates requests for PostV3Email with any type of body
func NewPostV3EmailRequestWithBody(server string, params *PostV3EmailParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Id", runtime.ParamLocationHeader, params.XClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Id", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Timestamp", runtime.ParamLocationHeader, params.XTimestamp)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Timestamp", headerParam1)

	}

	return req, nil
}

// NewPostV3SmsRequest calls the generic PostV3Sms builder with application/json body
func NewPostV3SmsRequest(server string, params *PostV3SmsParams, body PostV3SmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostV3SmsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostV3SmsRequestWithBody generates requests for PostV3Sms with any type of body
func NewPostV3SmsRequestWithBody(server string, params *PostV3SmsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/sms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Id", runtime.ParamLocationHeader, params.XClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Id", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Timestamp", runtime.ParamLocationHeader, params.XTimestamp)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Timestamp", headerParam1)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// PostV3EmailWithBodyWithResponse request with any body
	PostV3EmailWithBodyWithResponse(ctx context.Context, params *PostV3EmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3EmailResponse, error)

	PostV3EmailWithResponse(ctx context.Context, params *PostV3EmailParams, body PostV3EmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3EmailResponse, error)

	// PostV3SmsWithBodyWithResponse request with any body
	PostV3SmsWithBodyWithResponse(ctx context.Context, params *PostV3SmsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3SmsResponse, error)

	PostV3SmsWithResponse(ctx context.Context, params *PostV3SmsParams, body PostV3SmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3SmsResponse, error)
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status    *string    `json:"status,omitempty"`
		Timestamp *time.Time `json:"timestamp,omitempty"`
	}
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3EmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SuccessResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostV3EmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3EmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostV3SmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SmsSuccessResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostV3SmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostV3SmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// PostV3EmailWithBodyWithResponse request with arbitrary body returning *PostV3EmailResponse
func (c *ClientWithResponses) PostV3EmailWithBodyWithResponse(ctx context.Context, params *PostV3EmailParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3EmailResponse, error) {
	rsp, err := c.PostV3EmailWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3EmailResponse(rsp)
}

func (c *ClientWithResponses) PostV3EmailWithResponse(ctx context.Context, params *PostV3EmailParams, body PostV3EmailJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3EmailResponse, error) {
	rsp, err := c.PostV3Email(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3EmailResponse(rsp)
}

// PostV3SmsWithBodyWithResponse request with arbitrary body returning *PostV3SmsResponse
func (c *ClientWithResponses) PostV3SmsWithBodyWithResponse(ctx context.Context, params *PostV3SmsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostV3SmsResponse, error) {
	rsp, err := c.PostV3SmsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3SmsResponse(rsp)
}

func (c *ClientWithResponses) PostV3SmsWithResponse(ctx context.Context, params *PostV3SmsParams, body PostV3SmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostV3SmsResponse, error) {
	rsp, err := c.PostV3Sms(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostV3SmsResponse(rsp)
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status    *string    `json:"status,omitempty"`
			Timestamp *time.Time `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostV3EmailResponse parses an HTTP response from a PostV3EmailWithResponse call
func ParsePostV3EmailResponse(rsp *http.Response) (*PostV3EmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3EmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostV3SmsResponse parses an HTTP response from a PostV3SmsWithResponse call
func ParsePostV3SmsResponse(rsp *http.Response) (*PostV3SmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostV3SmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SmsSuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
