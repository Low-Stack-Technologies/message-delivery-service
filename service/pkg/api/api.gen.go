// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	SignatureAuthScopes = "signatureAuth.Scopes"
)

// EmailContact defines model for EmailContact.
type EmailContact struct {
	Address openapi_types.Email `json:"addres"`
	Name    *string             `json:"name,omitempty"`
}

// EmailRequest defines model for EmailRequest.
type EmailRequest struct {
	Content *EmailRequest_Content `json:"content,omitempty"`
	From    EmailContact          `json:"from"`
	Subject string                `json:"subject"`

	// To A single recipient or an array of recipients.
	To EmailRequest_To `json:"to"`
}

// EmailRequestContent0 defines model for .
type EmailRequestContent0 struct {
	Body   string `json:"body"`
	IsHtml *bool  `json:"isHtml,omitempty"`
}

// EmailRequestContent1 defines model for .
type EmailRequestContent1 struct {
	Template struct {
		Data map[string]interface{} `json:"data"`
		Name string                 `json:"name"`
	} `json:"template"`
}

// EmailRequest_Content defines model for EmailRequest.Content.
type EmailRequest_Content struct {
	union json.RawMessage
}

// EmailRequestTo0 defines model for .
type EmailRequestTo0 = openapi_types.Email

// EmailRequestTo2 defines model for .
type EmailRequestTo2 = []EmailRequest_To_2_Item

// EmailRequestTo20 defines model for .
type EmailRequestTo20 = openapi_types.Email

// EmailRequest_To_2_Item defines model for EmailRequest.To.2.Item.
type EmailRequest_To_2_Item struct {
	union json.RawMessage
}

// EmailRequest_To A single recipient or an array of recipients.
type EmailRequest_To struct {
	union json.RawMessage
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Code    string    `json:"code"`
		Details *[]string `json:"details,omitempty"`
		Message string    `json:"message"`
	} `json:"error"`
	Success bool `json:"success"`
}

// SmsRecipient defines model for SmsRecipient.
type SmsRecipient struct {
	union json.RawMessage
}

// SmsRecipient0 Phone number in E.164 format.
type SmsRecipient0 = string

// SmsRecipient1 defines model for .
type SmsRecipient1 struct {
	// Country ISO 3166-1 alpha-2 country code.
	Country string `json:"country"`
	Phone   string `json:"phone"`
}

// SmsRequest defines model for SmsRequest.
type SmsRequest struct {
	Content    *SmsRequest_Content `json:"content,omitempty"`
	SenderName string              `json:"senderName"`

	// To A single recipient or an array of recipients.
	To SmsRequest_To `json:"to"`
}

// SmsRequestContent0 defines model for .
type SmsRequestContent0 struct {
	Body string `json:"body"`
}

// SmsRequestContent1 defines model for .
type SmsRequestContent1 struct {
	Template struct {
		Data map[string]interface{} `json:"data"`
		Name string                 `json:"name"`
	} `json:"template"`
}

// SmsRequest_Content defines model for SmsRequest.Content.
type SmsRequest_Content struct {
	union json.RawMessage
}

// SmsRequestTo1 defines model for .
type SmsRequestTo1 = []SmsRecipient

// SmsRequest_To A single recipient or an array of recipients.
type SmsRequest_To struct {
	union json.RawMessage
}

// SmsSuccessResponse defines model for SmsSuccessResponse.
type SmsSuccessResponse struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	Message string                  `json:"message"`
	Meta    *struct {
		Cost     *float32 `json:"cost,omitempty"`
		Currency *string  `json:"currency,omitempty"`
	} `json:"meta,omitempty"`
	Success bool `json:"success"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	Message string                  `json:"message"`
	Success bool                    `json:"success"`
}

// ClientIdHeader defines model for ClientIdHeader.
type ClientIdHeader = string

// TimestampHeader defines model for TimestampHeader.
type TimestampHeader = time.Time

// PostV3EmailParams defines parameters for PostV3Email.
type PostV3EmailParams struct {
	// XClientId The unique ID assigned to your service.
	XClientId ClientIdHeader `json:"X-Client-Id"`

	// XTimestamp ISO 8601 timestamp. Requests older than 5 minutes will be rejected.
	XTimestamp TimestampHeader `json:"X-Timestamp"`
}

// PostV3SmsParams defines parameters for PostV3Sms.
type PostV3SmsParams struct {
	// XClientId The unique ID assigned to your service.
	XClientId ClientIdHeader `json:"X-Client-Id"`

	// XTimestamp ISO 8601 timestamp. Requests older than 5 minutes will be rejected.
	XTimestamp TimestampHeader `json:"X-Timestamp"`
}

// PostV3EmailJSONRequestBody defines body for PostV3Email for application/json ContentType.
type PostV3EmailJSONRequestBody = EmailRequest

// PostV3SmsJSONRequestBody defines body for PostV3Sms for application/json ContentType.
type PostV3SmsJSONRequestBody = SmsRequest

// AsEmailRequestContent0 returns the union data inside the EmailRequest_Content as a EmailRequestContent0
func (t EmailRequest_Content) AsEmailRequestContent0() (EmailRequestContent0, error) {
	var body EmailRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestContent0 overwrites any union data inside the EmailRequest_Content as the provided EmailRequestContent0
func (t *EmailRequest_Content) FromEmailRequestContent0(v EmailRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestContent0 performs a merge with any union data inside the EmailRequest_Content, using the provided EmailRequestContent0
func (t *EmailRequest_Content) MergeEmailRequestContent0(v EmailRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailRequestContent1 returns the union data inside the EmailRequest_Content as a EmailRequestContent1
func (t EmailRequest_Content) AsEmailRequestContent1() (EmailRequestContent1, error) {
	var body EmailRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestContent1 overwrites any union data inside the EmailRequest_Content as the provided EmailRequestContent1
func (t *EmailRequest_Content) FromEmailRequestContent1(v EmailRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestContent1 performs a merge with any union data inside the EmailRequest_Content, using the provided EmailRequestContent1
func (t *EmailRequest_Content) MergeEmailRequestContent1(v EmailRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailRequestTo20 returns the union data inside the EmailRequest_To_2_Item as a EmailRequestTo20
func (t EmailRequest_To_2_Item) AsEmailRequestTo20() (EmailRequestTo20, error) {
	var body EmailRequestTo20
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo20 overwrites any union data inside the EmailRequest_To_2_Item as the provided EmailRequestTo20
func (t *EmailRequest_To_2_Item) FromEmailRequestTo20(v EmailRequestTo20) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo20 performs a merge with any union data inside the EmailRequest_To_2_Item, using the provided EmailRequestTo20
func (t *EmailRequest_To_2_Item) MergeEmailRequestTo20(v EmailRequestTo20) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailContact returns the union data inside the EmailRequest_To_2_Item as a EmailContact
func (t EmailRequest_To_2_Item) AsEmailContact() (EmailContact, error) {
	var body EmailContact
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailContact overwrites any union data inside the EmailRequest_To_2_Item as the provided EmailContact
func (t *EmailRequest_To_2_Item) FromEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailContact performs a merge with any union data inside the EmailRequest_To_2_Item, using the provided EmailContact
func (t *EmailRequest_To_2_Item) MergeEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_To_2_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_To_2_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmailRequestTo0 returns the union data inside the EmailRequest_To as a EmailRequestTo0
func (t EmailRequest_To) AsEmailRequestTo0() (EmailRequestTo0, error) {
	var body EmailRequestTo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo0 overwrites any union data inside the EmailRequest_To as the provided EmailRequestTo0
func (t *EmailRequest_To) FromEmailRequestTo0(v EmailRequestTo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo0 performs a merge with any union data inside the EmailRequest_To, using the provided EmailRequestTo0
func (t *EmailRequest_To) MergeEmailRequestTo0(v EmailRequestTo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailContact returns the union data inside the EmailRequest_To as a EmailContact
func (t EmailRequest_To) AsEmailContact() (EmailContact, error) {
	var body EmailContact
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailContact overwrites any union data inside the EmailRequest_To as the provided EmailContact
func (t *EmailRequest_To) FromEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailContact performs a merge with any union data inside the EmailRequest_To, using the provided EmailContact
func (t *EmailRequest_To) MergeEmailContact(v EmailContact) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailRequestTo2 returns the union data inside the EmailRequest_To as a EmailRequestTo2
func (t EmailRequest_To) AsEmailRequestTo2() (EmailRequestTo2, error) {
	var body EmailRequestTo2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailRequestTo2 overwrites any union data inside the EmailRequest_To as the provided EmailRequestTo2
func (t *EmailRequest_To) FromEmailRequestTo2(v EmailRequestTo2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailRequestTo2 performs a merge with any union data inside the EmailRequest_To, using the provided EmailRequestTo2
func (t *EmailRequest_To) MergeEmailRequestTo2(v EmailRequestTo2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmailRequest_To) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmailRequest_To) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRecipient0 returns the union data inside the SmsRecipient as a SmsRecipient0
func (t SmsRecipient) AsSmsRecipient0() (SmsRecipient0, error) {
	var body SmsRecipient0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient0 overwrites any union data inside the SmsRecipient as the provided SmsRecipient0
func (t *SmsRecipient) FromSmsRecipient0(v SmsRecipient0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient0 performs a merge with any union data inside the SmsRecipient, using the provided SmsRecipient0
func (t *SmsRecipient) MergeSmsRecipient0(v SmsRecipient0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRecipient1 returns the union data inside the SmsRecipient as a SmsRecipient1
func (t SmsRecipient) AsSmsRecipient1() (SmsRecipient1, error) {
	var body SmsRecipient1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient1 overwrites any union data inside the SmsRecipient as the provided SmsRecipient1
func (t *SmsRecipient) FromSmsRecipient1(v SmsRecipient1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient1 performs a merge with any union data inside the SmsRecipient, using the provided SmsRecipient1
func (t *SmsRecipient) MergeSmsRecipient1(v SmsRecipient1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRecipient) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRecipient) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRequestContent0 returns the union data inside the SmsRequest_Content as a SmsRequestContent0
func (t SmsRequest_Content) AsSmsRequestContent0() (SmsRequestContent0, error) {
	var body SmsRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestContent0 overwrites any union data inside the SmsRequest_Content as the provided SmsRequestContent0
func (t *SmsRequest_Content) FromSmsRequestContent0(v SmsRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestContent0 performs a merge with any union data inside the SmsRequest_Content, using the provided SmsRequestContent0
func (t *SmsRequest_Content) MergeSmsRequestContent0(v SmsRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRequestContent1 returns the union data inside the SmsRequest_Content as a SmsRequestContent1
func (t SmsRequest_Content) AsSmsRequestContent1() (SmsRequestContent1, error) {
	var body SmsRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestContent1 overwrites any union data inside the SmsRequest_Content as the provided SmsRequestContent1
func (t *SmsRequest_Content) FromSmsRequestContent1(v SmsRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestContent1 performs a merge with any union data inside the SmsRequest_Content, using the provided SmsRequestContent1
func (t *SmsRequest_Content) MergeSmsRequestContent1(v SmsRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSmsRecipient returns the union data inside the SmsRequest_To as a SmsRecipient
func (t SmsRequest_To) AsSmsRecipient() (SmsRecipient, error) {
	var body SmsRecipient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRecipient overwrites any union data inside the SmsRequest_To as the provided SmsRecipient
func (t *SmsRequest_To) FromSmsRecipient(v SmsRecipient) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRecipient performs a merge with any union data inside the SmsRequest_To, using the provided SmsRecipient
func (t *SmsRequest_To) MergeSmsRecipient(v SmsRecipient) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsRequestTo1 returns the union data inside the SmsRequest_To as a SmsRequestTo1
func (t SmsRequest_To) AsSmsRequestTo1() (SmsRequestTo1, error) {
	var body SmsRequestTo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsRequestTo1 overwrites any union data inside the SmsRequest_To as the provided SmsRequestTo1
func (t *SmsRequest_To) FromSmsRequestTo1(v SmsRequestTo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsRequestTo1 performs a merge with any union data inside the SmsRequest_To, using the provided SmsRequestTo1
func (t *SmsRequest_To) MergeSmsRequestTo1(v SmsRequestTo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SmsRequest_To) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SmsRequest_To) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Service Health Check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// Send an Email
	// (POST /v3/email)
	PostV3Email(w http.ResponseWriter, r *http.Request, params PostV3EmailParams)
	// Send an SMS
	// (POST /v3/sms)
	PostV3Sms(w http.ResponseWriter, r *http.Request, params PostV3SmsParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Service Health Check
// (GET /health)
func (_ Unimplemented) GetHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send an Email
// (POST /v3/email)
func (_ Unimplemented) PostV3Email(w http.ResponseWriter, r *http.Request, params PostV3EmailParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send an SMS
// (POST /v3/sms)
func (_ Unimplemented) PostV3Sms(w http.ResponseWriter, r *http.Request, params PostV3SmsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostV3Email operation middleware
func (siw *ServerInterfaceWrapper) PostV3Email(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SignatureAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV3EmailParams

	headers := r.Header

	// ------------- Required header parameter "X-Client-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Id")]; found {
		var XClientId ClientIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Client-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Client-Id", valueList[0], &XClientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Client-Id", Err: err})
			return
		}

		params.XClientId = XClientId

	} else {
		err := fmt.Errorf("Header parameter X-Client-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Client-Id", Err: err})
		return
	}

	// ------------- Required header parameter "X-Timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Timestamp")]; found {
		var XTimestamp TimestampHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Timestamp", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Timestamp", valueList[0], &XTimestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Timestamp", Err: err})
			return
		}

		params.XTimestamp = XTimestamp

	} else {
		err := fmt.Errorf("Header parameter X-Timestamp is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Timestamp", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostV3Email(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostV3Sms operation middleware
func (siw *ServerInterfaceWrapper) PostV3Sms(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, SignatureAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostV3SmsParams

	headers := r.Header

	// ------------- Required header parameter "X-Client-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Id")]; found {
		var XClientId ClientIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Client-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Client-Id", valueList[0], &XClientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Client-Id", Err: err})
			return
		}

		params.XClientId = XClientId

	} else {
		err := fmt.Errorf("Header parameter X-Client-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Client-Id", Err: err})
		return
	}

	// ------------- Required header parameter "X-Timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Timestamp")]; found {
		var XTimestamp TimestampHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Timestamp", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Timestamp", valueList[0], &XTimestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Timestamp", Err: err})
			return
		}

		params.XTimestamp = XTimestamp

	} else {
		err := fmt.Errorf("Header parameter X-Timestamp is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Timestamp", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostV3Sms(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.GetHealth)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v3/email", wrapper.PostV3Email)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v3/sms", wrapper.PostV3Sms)
	})

	return r
}
